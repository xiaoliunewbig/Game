# 代码规范（C++/Python/Protobuf）

---

## 1. 目录结构与文件组织
- 根目录下分层：algorithm（算法层）、strategy（策略层）、application（应用层）、tools（Python工具）、docs（文档）、tests（测试）、scripts（脚本）、configs（配置）、proto（协议文件）。
- 每个模块下分 src（源码）、include（头文件）、test（测试）、CMakeLists.txt。
- 资源、配置、脚本、测试分目录管理，命名清晰。
- proto 文件统一放在 proto 目录，按服务分文件。

---

## 2. C++ 代码规范
### 2.1 头文件保护
```cpp
#ifndef MODULE_CLASSNAME_H
#define MODULE_CLASSNAME_H
// ...
#endif // MODULE_CLASSNAME_H
```

### 2.2 智能指针优先
- 禁止裸指针管理资源，优先使用 std::unique_ptr、std::shared_ptr。
- 禁止手动 new/delete。

### 2.3 命名空间
- 使用项目/模块前缀，避免全局污染。
```cpp
namespace game_core {
    class BattleManager {};
}
```

### 2.4 类与成员
- 成员变量加下划线结尾：`health_`。
- 禁止 public 成员变量，使用 getter/setter。
- 构造函数显式 explicit。

### 2.5 异常与错误处理
- 业务异常自定义继承 std::exception。
- 捕获异常时使用引用：`catch(const std::exception& e)`。
- 日志记录所有异常。

### 2.6 注释规范
- 类、函数、复杂逻辑必须有注释。
- Doxygen 风格推荐：
```cpp
/**
 * @brief 计算伤害
 * @param attackerId 攻击者ID
 * @param defenderId 防御者ID
 * @return 伤害值
 */
int CalculateDamage(int attackerId, int defenderId);
```

### 2.7 单元测试
- 使用 Google Test，测试文件与源文件同名，放在 test 目录。
- 测试覆盖率不低于 80%。

### 2.8 其他
- 禁止 using namespace std。
- 禁止魔法数字，常量集中定义。
- 头文件只包含必要依赖，使用前向声明。
- 统一 4 空格缩进。

---

## 3. Python 代码规范
### 3.1 类型注解
- 所有函数、方法参数和返回值必须加类型注解。
```python
def load_config(path: str) -> dict:
    ...
```

### 3.2 异常与日志
- 自定义异常类，捕获并记录日志。
- 日志使用 logging 模块，禁止 print。

### 3.3 包结构
- 每个功能模块单独包，__init__.py 必须存在。
- 工具脚本放 tools 目录，测试放 tests 目录。

### 3.4 依赖管理
- 使用 requirements.txt 或 pyproject.toml 管理依赖。
- 禁止在代码中硬编码依赖路径。

### 3.5 注释与文档
- 函数、类、复杂逻辑必须有 docstring。
- 推荐 Google 风格注释：
```python
def foo(bar: int) -> int:
    """
    计算示例函数。
    Args:
        bar (int): 输入参数
    Returns:
        int: 结果
    """
    ...
```

### 3.6 代码风格
- 遵循 PEP8，4 空格缩进。
- 每行不超过 120 字符。
- 禁止魔法数字，常量集中定义。

---

## 4. Protobuf 代码规范
### 4.1 版本与语法
- 统一使用 proto3。
- 文件头注明版本和作者。
```protobuf
syntax = "proto3";
// v1.0.0, author: xxx
```

### 4.2 命名规范
- 消息、服务：大驼峰（PascalCase）。
- 字段：下划线分隔（snake_case）。
- 枚举：大驼峰，枚举值全大写+下划线。

### 4.3 注释
- 每个 message、service、字段必须有注释。

### 4.4 兼容性
- 字段编号不可变更或复用。
- 删除字段保留编号，添加字段递增编号。

### 4.5 嵌套与扩展
- 复杂结构使用嵌套 message。
- 公共字段抽象为 BaseRequest/BaseResponse。

### 4.6 示例
```protobuf
// algorithm.proto
syntax = "proto3";

// 战斗计算请求
message CalculateDamageRequest {
  string trace_id = 1; // 请求追踪ID
  int64 timestamp = 2; // 时间戳
  int32 attacker_id = 3; // 攻击者ID
  int32 defender_id = 4; // 防御者ID
  int32 skill_id = 5;    // 技能ID
}

// 战斗计算响应
message CalculateDamageResponse {
  int32 code = 1;      // 错误码
  string message = 2;  // 错误信息
  int64 timestamp = 3; // 时间戳
  int32 damage = 4;    // 伤害值
  string effect = 5;   // 效果描述
}
```

---

## 5. 通用规范
### 5.1 代码审查
- 所有合并需至少一人评审。
- 评审关注可读性、健壮性、性能、注释。

### 5.2 分支管理
- 主分支 main/master，开发分支 feature/xxx，修复分支 fix/xxx。
- 重要变更需开 PR，禁止直接推送主分支。

### 5.3 提交规范
- 提交信息格式：`[模块] 简要描述`，如 `[algorithm] 实现伤害计算接口`。
- 一次提交只做一件事。

### 5.4 文档要求
- 重要模块、接口、协议需有详细文档。
- 变更需同步更新文档。

### 5.5 其他
- 禁止提交临时代码、调试语句。
- 资源文件需注明来源和用途。
- 代码合并前需通过所有测试。

---

## 6. 代码示例
### 6.1 C++ 类定义
```cpp
// 文件: battle_manager.h
#ifndef ALGORITHM_BATTLE_MANAGER_H
#define ALGORITHM_BATTLE_MANAGER_H

namespace algorithm {

/**
 * @brief 战斗管理器
 */
class BattleManager {
 public:
  explicit BattleManager(int seed);
  int CalculateDamage(int attackerId, int defenderId, int skillId) const;

 private:
  int seed_;
};

} // namespace algorithm

#endif // ALGORITHM_BATTLE_MANAGER_H
```

### 6.2 Python 工具
```python
# 文件: tools/data_validator.py
import logging

def validate_data(data: dict) -> bool:
    """
    校验数据合法性。
    Args:
        data (dict): 输入数据
    Returns:
        bool: 是否合法
    """
    if not data:
        logging.error("数据为空")
        return False
    # ...
    return True
```

### 6.3 Protobuf 消息
```protobuf
// 文件: proto/algorithm.proto
syntax = "proto3";

// 计算伤害请求
message CalculateDamageRequest {
  string trace_id = 1;
  int64 timestamp = 2;
  int32 attacker_id = 3;
  int32 defender_id = 4;
  int32 skill_id = 5;
}
```

---

如需进一步细化某一部分或补充更多示例，请随时告知！ 