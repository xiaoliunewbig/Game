# 《幻境传说》三层架构开发文档

---

## 1. 架构分层设计

### 1.1 分层原则
- **单向依赖**：上层调用下层接口，不反向依赖  
- **职责分离**：每层只关注自身核心功能  
- **接口抽象**：通过 gRPC/Protobuf 定义标准化接口  
- **数据流向**：  
  `Algorithm Service`（算法层）  
  ↓  
  `Strategy Service`（策略层）  
  ↓  
  `Qt Application`（应用层）

---

## 2. 算法层（Algorithm Service）

### 2.1 架构设计
```
┌──────────────────────────────┐
│      Algorithm Service       │
├──────────────────────────────┤
│  ┌─────────────────────────┐ │
│  │ Combat Engine           │ │
│  │ - 伤害计算公式          │ │
│  │ - 元素克制逻辑          │ │
│  │ - 状态效果模拟          │ │
│  └─────────────────────────┘ │
│                              │
│  ┌─────────────────────────┐ │
│  │ AI Decision Engine      │ │
│  │ - 决策树构建            │ │
│  │ - 行为树执行器          │ │
│  │ - 战术分析模块          │ │
│  └─────────────────────────┘ │
│                              │
│  ┌─────────────────────────┐ │
│  │ Data Validator          │ │
│  │ - 输入合法性校验        │ │
│  │ - 数据范围检查          │ │
│  │ - 格式标准化转换        │ │
│  └─────────────────────────┘ │
└──────────────────────────────┘
```

### 2.2 核心模块
#### 1. 战斗引擎
- **伤害计算公式**：
  ```cpp
  // 示例：基础伤害公式
  float CalculateDamage(const Character& attacker, const Character& defender) {
    float base = attacker.GetAttack() * (1 + attacker.GetElementalBonus(defender.Element));
    return base * (1 - defender.GetDefenseMultiplier());
  }
  ```
- **元素克制矩阵**：
  ```json
  {
    "fire": {"water": 0.5, "grass": 2.0},
    "water": {"fire": 2.0, "grass": 0.5}
  }
  ```

#### 2. AI 决策系统
- **行为树示例**：
  ```mermaid
  graph TD
    A[根节点] --> B{条件检查}
    B -->|条件成立| C[攻击动作]
    B -->|条件不成立| D[防御动作]
  ```

#### 3. 数据校验模块
- **校验规则**：
  ```protobuf
  message ValidationRules {
    map<string, float> numeric_ranges = 1; // 例如 {"hp": 0~10000}
    map<string, string> enum_values = 2;   // 例如 {"element": ["fire", "water"]}
  }
  ```

### 2.3 通信接口
```protobuf
// algorithm.proto
service AlgorithmService {
  // 战斗计算
  rpc CalculateDamage(CalculationRequest) returns (DamageResult);
  // 技能树数据
  rpc GetSkillTree(SkillTreeRequest) returns (SkillTree);
  // AI 决策
  rpc AIActionDecision(AIDecisionRequest) returns (ActionResponse);
  // 数据校验
  rpc ValidateInput(ValidationRequest) returns (ValidationResult);
}
```

---

## 3. 策略层（Strategy Service）

### 3.1 架构设计
```
┌──────────────────────────────┐
│      Strategy Service        │
├──────────────────────────────┤
│  ┌─────────────────────────┐ │
│  │ Game Rule Manager       │ │
│  │ - 战斗规则存储          │ │
│  │ - 剧情触发条件          │ │
│  └─────────────────────────┘ │
│                              │
│  ┌─────────────────────────┐ │
│  │ World State Engine      │ │
│  │ - NPC关系图谱          │ │
│  │ - 世界状态持久化        │ │
│  └─────────────────────────┘ │
│                              │
│  ┌─────────────────────────┐ │
│  │ Event Scheduler         │ │
│  │ - 任务触发系统          │ │
│  │ - 状态更新队列          │ │
│  └─────────────────────────┘ │
└──────────────────────────────┘
```

### 3.2 核心模块
#### 1. 游戏规则管理
- **规则存储**：
  ```sql
  CREATE TABLE game_rules (
    rule_id TEXT PRIMARY KEY,
    description TEXT,
    condition JSON,
    effect JSON
  );
  ```

#### 2. 世界状态引擎
- **NPC关系图谱**：
  ```json
  {
    "player": {
      "trust": 80,
      "friends": ["guard_001", "merchant_002"],
      "enemies": ["bandit_003"]
    }
  }
  ```

#### 3. 事件调度中心
- **事件队列**：
  ```cpp
  class EventQueue {
  public:
    void ScheduleEvent(Event event, TimePoint time);
    std::vector<Event> GetDueEvents();
  };
  ```

### 3.3 通信接口
```protobuf
// strategy.proto
service StrategyService {
  // 获取游戏规则
  rpc GetGameRules(RulesRequest) returns (GameRules);
  // 更新世界状态
  rpc UpdateWorldState(WorldStateUpdate) returns (Status);
  // 触发事件
  rpc TriggerEvent(EventTrigger) returns (EventResult);
  // 查询当前状态
  rpc QueryGameState(QueryRequest) returns (GameState);
}
```

---

## 4. 应用层（Qt Application）

### 4.1 架构设计
```
┌──────────────────────────────┐
│      Qt Application          │
├──────────────────────────────┤
│  ┌─────────────────────────┐ │
│  │ UI System               │ │
│  │ - QML场景渲染           │ │
│  │ - 动态UI组件            │ │
│  └─────────────────────────┘ │
│                              │
│  ┌─────────────────────────┐ │
│  │ Input Handler           │ │
│  │ - 战斗操作映射          │ │
│  │ - 菜单交互处理          │ │
│  └─────────────────────────┘ │
│                              │
│  ┌─────────────────────────┐ │
│  │ Resource Manager        │ │
│  │ - 纹理加载/释放         │ │
│  │ - 音效播放控制          │ │
│  └─────────────────────────┘ │
└──────────────────────────────┘
```

### 4.2 核心模块
#### 1. UI 系统
- **QML 场景示例**：
  ```qml
  Item {
    width: 800
    height: 600

    Rectangle {
      color: "black"
      anchors.fill: parent

      Text {
        text: "HP: " + player.hp
        color: "white"
        anchors.top: parent.top
        anchors.left: parent.left
      }
    }
  }
  ```

#### 2. 输入处理
- **战斗操作映射**：
  ```cpp
  enum class InputAction {
    ATTACK,
    DEFEND,
    SKILL_1,
    SKILL_2
  };

  class InputMapper {
  public:
    InputAction MapKey(Qt::Key key);
  };
  ```

#### 3. 资源管理
- **资源加载器**：
  ```cpp
  class ResourceManager {
  public:
    QImage LoadTexture(const QString& path);
    QSoundEffect* LoadSound(const QString& path);
  };
  ```

### 4.3 通信接口
```cpp
// 示例：调用策略层获取游戏规则
auto channel = grpc::CreateChannel("localhost:50052", grpc::InsecureChannelCredentials());
auto stub = StrategyService::NewStub(channel);
StrategyService::GetGameRulesRequest request;
request.set_rule_id("combat_rules");
auto response = stub->GetGameRules(&context, request);
```

---

## 5. 三层交互示例

### 5.1 数据流示意图
```
[玩家攻击操作] 
  ↓ 应用层处理输入
[调用 AlgorithmService.CalculateDamage] 
  ↓ 算法层计算伤害
[返回结果给 StrategyService.UpdateWorldState] 
  ↓ 策略层更新NPC状态
[触发 EventScheduler 事件] 
  ↓ 最终更新UI显示
```

### 5.2 事件总线示例
```json
{
  "event_type": "NPC_STATE_CHANGED",
  "target": "guard_001",
  "new_state": {
    "health": 50,
    "status_effects": ["poisoned"]
  }
}
```

---

## 6. 扩展性设计

### 6.1 插件系统
- **算法层插件**：
  ```cpp
  class CustomDamageCalculator : public GamePlugin {
  public:
    void onLoad() override { RegisterDamageCalculator(); }
    float CalculateCustomDamage(...) override;
  };
  ```

- **策略层插件**：
  ```cpp
  class DynamicEventPlugin : public GamePlugin {
  public:
    void onTick(float delta) override {
      if (Random() < 0.01) {
        TriggerRandomEvent();
      }
    }
  };
  ```

---

## 7. 性能优化

### 7.1 各层优化策略
| 层级       | 优化点                | 实现方式                          |
|------------|-----------------------|-----------------------------------|
| **算法层** | 并行计算              | 使用 C++20 并行算法              |
| **策略层** | 事件批处理            | 将多个状态更新合并为单次操作     |
| **应用层** | 异步资源加载          | 使用 QtConcurrent 进行后台加载   |

---

## 8. 部署架构

### 8.1 微服务拓扑
```
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ Python Tools  │   │ Algorithm     │   │ Strategy      │
│ (Level Editor)│<──>│ Service       │<──>│ Service       │
└───────────────┘   └───────────────┘   └───────────────┘
                                                  ↓
                                          ┌─────────────────┐
                                          │ Qt Application  │
                                          └─────────────────┘
```

---

## 9. 开发建议

1. **优先实现核心战斗系统**：
   - 完成算法层的 `CalculateDamage` 和策略层的 `UpdateWorldState`
2. **逐步扩展功能**：
   - 先实现主线剧情系统，再开发支线任务
3. **自动化测试**：
   - 为算法层编写基准测试（Google Benchmark）
   - 为策略层实现集成测试（Catch2）

---

## 10. 结论

本架构设计通过严格的分层解耦，实现了：
- **高性能计算**：算法层专注复杂逻辑
- **灵活规则管理**：策略层统一控制游戏逻辑
- **流畅用户体验**：应用层专注于 UI 和交互
- **可扩展性**：通过插件系统支持功能扩展

建议采用 **渐进式开发策略**，优先验证核心战斗循环，再逐步完善剧情系统和动态世界功能。